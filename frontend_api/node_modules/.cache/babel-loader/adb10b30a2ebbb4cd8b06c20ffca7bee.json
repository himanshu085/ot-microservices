{"ast":null,"code":"import { stripQueryStringFromUrl } from '../../common/utils';\nimport { shouldCreateSpan } from './utils';\nimport { RESOURCE_INITIATOR_TYPES } from '../../common/constants';\nimport Span from '../span';\nfunction createResourceTimingSpan(resourceTimingEntry) {\n  var name = resourceTimingEntry.name,\n    initiatorType = resourceTimingEntry.initiatorType,\n    startTime = resourceTimingEntry.startTime,\n    responseEnd = resourceTimingEntry.responseEnd;\n  var kind = 'resource';\n  if (initiatorType) {\n    kind += '.' + initiatorType;\n  }\n  var spanName = stripQueryStringFromUrl(name);\n  var span = new Span(spanName, kind);\n  span._start = startTime;\n  span.end(responseEnd, {\n    url: name,\n    entry: resourceTimingEntry\n  });\n  return span;\n}\nfunction isCapturedByPatching(resourceStartTime, requestPatchTime) {\n  return requestPatchTime != null && resourceStartTime > requestPatchTime;\n}\nfunction isIntakeAPIEndpoint(url) {\n  return /intake\\/v\\d+\\/rum\\/events/.test(url);\n}\nfunction createResourceTimingSpans(entries, requestPatchTime, trStart, trEnd) {\n  var spans = [];\n  for (var i = 0; i < entries.length; i++) {\n    var _entries$i = entries[i],\n      initiatorType = _entries$i.initiatorType,\n      name = _entries$i.name,\n      startTime = _entries$i.startTime,\n      responseEnd = _entries$i.responseEnd;\n    if (RESOURCE_INITIATOR_TYPES.indexOf(initiatorType) === -1 || name == null) {\n      continue;\n    }\n    if ((initiatorType === 'xmlhttprequest' || initiatorType === 'fetch') && (isIntakeAPIEndpoint(name) || isCapturedByPatching(startTime, requestPatchTime))) {\n      continue;\n    }\n    if (shouldCreateSpan(startTime, responseEnd, trStart, trEnd)) {\n      spans.push(createResourceTimingSpan(entries[i]));\n    }\n  }\n  return spans;\n}\nexport { createResourceTimingSpans };","map":null,"metadata":{},"sourceType":"module"}