{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { LONG_TASK, LARGEST_CONTENTFUL_PAINT, FIRST_CONTENTFUL_PAINT, FIRST_INPUT, LAYOUT_SHIFT } from '../../common/constants';\nimport { noop, PERF, isPerfTypeSupported, isRedirectInfoAvailable } from '../../common/utils';\nimport Span from '../span';\nexport var metrics = {\n  fid: 0,\n  fcp: 0,\n  tbt: {\n    start: Infinity,\n    duration: 0\n  },\n  cls: {\n    score: 0,\n    firstEntryTime: Number.NEGATIVE_INFINITY,\n    prevEntryTime: Number.NEGATIVE_INFINITY,\n    currentSessionScore: 0\n  },\n  longtask: {\n    count: 0,\n    duration: 0,\n    max: 0\n  }\n};\nvar LONG_TASK_THRESHOLD = 50;\nexport function createLongTaskSpans(longtasks, agg) {\n  var spans = [];\n  for (var i = 0; i < longtasks.length; i++) {\n    var _longtasks$i = longtasks[i],\n      name = _longtasks$i.name,\n      startTime = _longtasks$i.startTime,\n      duration = _longtasks$i.duration,\n      attribution = _longtasks$i.attribution;\n    var end = startTime + duration;\n    var span = new Span(\"Longtask(\" + name + \")\", LONG_TASK, {\n      startTime: startTime\n    });\n    agg.count++;\n    agg.duration += duration;\n    agg.max = Math.max(duration, agg.max);\n    if (attribution.length > 0) {\n      var _attribution$ = attribution[0],\n        _name = _attribution$.name,\n        containerType = _attribution$.containerType,\n        containerName = _attribution$.containerName,\n        containerId = _attribution$.containerId;\n      var customContext = {\n        attribution: _name,\n        type: containerType\n      };\n      if (containerName) {\n        customContext.name = containerName;\n      }\n      if (containerId) {\n        customContext.id = containerId;\n      }\n      span.addContext({\n        custom: customContext\n      });\n    }\n    span.end(end);\n    spans.push(span);\n  }\n  return spans;\n}\nexport function createFirstInputDelaySpan(fidEntries) {\n  var firstInput = fidEntries[0];\n  if (firstInput) {\n    var startTime = firstInput.startTime,\n      processingStart = firstInput.processingStart;\n    var span = new Span('First Input Delay', FIRST_INPUT, {\n      startTime: startTime\n    });\n    span.end(processingStart);\n    return span;\n  }\n}\nexport function createTotalBlockingTimeSpan(tbtObject) {\n  var start = tbtObject.start,\n    duration = tbtObject.duration;\n  var tbtSpan = new Span('Total Blocking Time', LONG_TASK, {\n    startTime: start\n  });\n  tbtSpan.end(start + duration);\n  return tbtSpan;\n}\nexport function calculateTotalBlockingTime(longtaskEntries) {\n  longtaskEntries.forEach(function (entry) {\n    var name = entry.name,\n      startTime = entry.startTime,\n      duration = entry.duration;\n    if (startTime < metrics.fcp) {\n      return;\n    }\n    if (name !== 'self' && name.indexOf('same-origin') === -1) {\n      return;\n    }\n    metrics.tbt.start = Math.min(metrics.tbt.start, startTime);\n    var blockingTime = duration - LONG_TASK_THRESHOLD;\n    if (blockingTime > 0) {\n      metrics.tbt.duration += blockingTime;\n    }\n  });\n}\nexport function calculateCumulativeLayoutShift(clsEntries) {\n  clsEntries.forEach(function (entry) {\n    if (!entry.hadRecentInput && entry.value) {\n      var shouldCreateNewSession = entry.startTime - metrics.cls.firstEntryTime > 5000 || entry.startTime - metrics.cls.prevEntryTime > 1000;\n      if (shouldCreateNewSession) {\n        metrics.cls.firstEntryTime = entry.startTime;\n        metrics.cls.currentSessionScore = 0;\n      }\n      metrics.cls.prevEntryTime = entry.startTime;\n      metrics.cls.currentSessionScore += entry.value;\n      metrics.cls.score = Math.max(metrics.cls.score, metrics.cls.currentSessionScore);\n    }\n  });\n}\nexport function captureObserverEntries(list, _ref) {\n  var isHardNavigation = _ref.isHardNavigation,\n    trStart = _ref.trStart;\n  var longtaskEntries = list.getEntriesByType(LONG_TASK).filter(function (entry) {\n    return entry.startTime >= trStart;\n  });\n  var longTaskSpans = createLongTaskSpans(longtaskEntries, metrics.longtask);\n  var result = {\n    spans: longTaskSpans,\n    marks: {}\n  };\n  if (!isHardNavigation) {\n    return result;\n  }\n  var lcpEntries = list.getEntriesByType(LARGEST_CONTENTFUL_PAINT);\n  var lastLcpEntry = lcpEntries[lcpEntries.length - 1];\n  if (lastLcpEntry) {\n    var lcp = parseInt(lastLcpEntry.startTime);\n    metrics.lcp = lcp;\n    result.marks.largestContentfulPaint = lcp;\n  }\n  var timing = PERF.timing;\n  var unloadDiff = timing.fetchStart - timing.navigationStart;\n  if (isRedirectInfoAvailable(timing)) {\n    unloadDiff = 0;\n  }\n  var fcpEntry = list.getEntriesByName(FIRST_CONTENTFUL_PAINT)[0];\n  if (fcpEntry) {\n    var fcp = parseInt(unloadDiff >= 0 ? fcpEntry.startTime - unloadDiff : fcpEntry.startTime);\n    metrics.fcp = fcp;\n    result.marks.firstContentfulPaint = fcp;\n  }\n  var fidEntries = list.getEntriesByType(FIRST_INPUT);\n  var fidSpan = createFirstInputDelaySpan(fidEntries);\n  if (fidSpan) {\n    metrics.fid = fidSpan.duration();\n    result.spans.push(fidSpan);\n  }\n  calculateTotalBlockingTime(longtaskEntries);\n  var clsEntries = list.getEntriesByType(LAYOUT_SHIFT);\n  calculateCumulativeLayoutShift(clsEntries);\n  return result;\n}\nexport var PerfEntryRecorder = function () {\n  function PerfEntryRecorder(callback) {\n    this.po = {\n      observe: noop,\n      disconnect: noop\n    };\n    if (window.PerformanceObserver) {\n      this.po = new PerformanceObserver(callback);\n    }\n  }\n  var _proto = PerfEntryRecorder.prototype;\n  _proto.start = function start(type, options) {\n    if (options === void 0) {\n      options = {\n        buffered: true\n      };\n    }\n    try {\n      if (!isPerfTypeSupported(type)) {\n        return;\n      }\n      this.po.observe(_extends({\n        type: type\n      }, options));\n    } catch (_) {}\n  };\n  _proto.stop = function stop() {\n    this.po.disconnect();\n  };\n  return PerfEntryRecorder;\n}();","map":null,"metadata":{},"sourceType":"module"}